schemaVersion: 1
id: Amp_Subagent_System_Architecture_20260217_050706
stableId: 86f0d699-a96e-49ed-87c7-66f617a7c53c
metadata:
  cascadeId: 2b172413-3c77-4bc7-9405-215ba7fbd3f7
  generationSource: generationWithTraces
  generationTimestamp: "2026-02-17T05:07:06+01:00"
  mode: FAST
  originalPrompt: "Explore: Amp Subagent System Architecture. Core components and interaction patterns of the subagent system\nStart from: subagent.py, core.py, agent_manager.py"
title: Amp Subagent System Architecture
traces[5]:
  - id: "1"
    title: Amp Subagent Spawning Flow
    description: Core Amp system showing how subagents are created and executed via AgentRunner
    locations[4]{id,path,lineNumber,lineContent,title,description}:
      1a,/Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md,25,runLibrarianSubagent(),Subagent Spawn Entry Point,The concrete pattern for spawning librarian subagents with tool scoping
      1b,/Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md,26,"{...AGENT_CONFIGS.librarian, includeTools: availableTools}",Agent Spec Construction,Tool sets are scoped per subagent type
      1c,/Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md,27,new AgentRunner().run() with inference config + spec + context,AgentRunner Execution,Core execution call that creates the subagent process
      1d,/Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md,27,pipes output through `map(processLibrarianOutput)`,Output Processing,Results are processed and mapped back to parent agent
    traceTextDiagram: "Amp CLI Entry Point\n├── CLI argument parsing (-x, --dangerously-allow-all) <-- /Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md:44\n├── Subagent Spawn Request\n│   └── runLibrarianSubagent() <-- 1a\n│       ├── Agent Spec Construction\n│       │   └── {...AGENT_CONFIGS.librarian} <-- 1b\n│       ├── createRunner() inner function <-- /Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md:27\n│       │   └── new AgentRunner().run() <-- 1c\n│       └── Output Processing Pipeline\n│           └── map(processLibrarianOutput) <-- 1d\n└── AgentRunner Core System\n    ├── inferenceConfig + spec + context <-- /Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md:27\n    ├── toolService coordination <-- /Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md:27\n    └── Observable stream with status updates <-- /Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md:57"
    traceGuide: "# Motivation\n\nAmp needs to **parallelize complex coding tasks** across multiple specialized AI agents. A single agent trying to handle large-scale refactors, multi-file implementations, or concurrent research becomes a bottleneck. The subagent system solves this by spawning focused, fire-and-forget worker agents that can run in parallel, each with specific tool sets and contexts, while the parent agent orchestrates the overall workflow.\n\n# Details\n\nThe subagent spawning process begins with CLI argument parsing to detect execute mode flags like `-x` and `--dangerously-allow-all` [1a]. When a subagent is needed, Amp constructs an **agent specification** that defines which tools the subagent can access - for example, a librarian subagent gets repository tools while a code execution subagent gets file editing tools [1b]. The system then creates an inner runner function that instantiates `AgentRunner` with inference configuration, system prompt, and the agent specification [1c]. This runner executes the subagent in a controlled environment and pipes the output through a processing function that formats results for the parent agent [1d]. The entire system is built around **resource locking** and **dependency management** to prevent conflicts when multiple subagents work on the same codebase simultaneously."
  - id: "2"
    title: Cline Subagent Execution Engine
    description: Cline's SubagentRunner implementation showing the complete execution lifecycle
    locations[5]{id,path,lineNumber,lineContent,title,description}:
      2a,/Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts,279,"async run(prompt: string, onProgress: (update: SubagentProgressUpdate) => void): Promise<SubagentRunResult>",Subagent Run Entry Point,Main execution method with progress callback
      2b,/Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts,305,"const api = buildApiHandler(effectiveApiConfiguration, mode)",API Handler Creation,Builds API connection for subagent communication
      2c,/Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts,340,const systemPrompt = (await promptRegistry.get(context)) + SUBAGENT_SYSTEM_SUFFIX,System Prompt Construction,Builds specialized subagent system prompt
      2d,/Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts,414,for await (const chunk of stream),Stream Processing Loop,Processes streaming responses from subagent
      2e,/Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts,611,"toolResult = await handler.execute(subagentConfig, toolCallBlock)",Tool Execution,Executes individual tool calls within subagent context
    traceTextDiagram: "Cline Subagent Execution Engine\n├── run() method entry point <-- 2a\n│   ├── Build API handler for communication <-- 2b\n│   ├── Construct system prompt + suffix <-- 2c\n│   ├── Process streaming response loop <-- 2d\n│   │   ├── Handle usage chunks <-- /Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts:416\n│   │   ├── Handle text chunks <-- /Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts:434\n│   │   └── Handle tool_calls chunks <-- /Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts:438\n│   │       └── Execute tool via handler <-- 2e\n│   └── Return completed result <-- /Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts:577\n└── Progress callbacks throughout execution <-- /Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts:296\n    └── Stats and status updates <-- /Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts:431"
    traceGuide: "# Motivation\n\nAI coding agents need to **delegate work** to specialized subagents for parallel processing, but managing these subagents safely is complex. The SubagentRunner solves this by providing a **secure execution sandbox** where subagents can work independently while the parent maintains control. This enables tasks like code exploration, file analysis, and multi-file edits to happen **concurrently** without conflicts, dramatically speeding up complex development workflows.\n\n# Details\n\nThe system starts with the `run()` method [2a] which establishes the execution environment. It first builds an API handler [2b] to communicate with the AI model, then constructs a specialized system prompt [2c] that tells the subagent its role and limitations. The core execution happens in a streaming response loop [2d] that processes three types of chunks: usage statistics, text responses, and tool calls. When tools are invoked, they execute through handlers [2e] with carefully scoped permissions. Throughout execution, progress callbacks provide real-time updates, and the system maintains strict resource limits and error handling to ensure subagents can't compromise the parent session or access unauthorized resources."
  - id: "3"
    title: Self-Subagent Orchestration
    description: The self-subagent skill showing dependency management and wave-based parallel execution
    locations[5]{id,path,lineNumber,lineContent,title,description}:
      3a,/Users/pcstyle/skills/self-subagent/SKILL.md,192,"spawn_task() { timeout 300 $AGENT_CMD \"$prompt\" > \"$TMPDIR/$id.out\" 2>&1 & }",Task Spawning Function,Core function to spawn individual subagent tasks
      3b,/Users/pcstyle/skills/self-subagent/references/orchestration.md,41,"deps_met() { [[ \"${TASK_STATUS[$dep]}\" != \"done\" ]] && return 1 }",Dependency Checking,Verifies all dependencies are completed before execution
      3c,/Users/pcstyle/skills/self-subagent/references/orchestration.md,53,"write_conflict() { [[ \"$my_file\" == \"$other_file\" ]] && return 0 }",Write Conflict Detection,Prevents parallel tasks from writing same files
      3d,/Users/pcstyle/skills/self-subagent/references/orchestration.md,77,"dispatch_ready() { deps_met \"$id\" || continue; write_conflict \"$id\" && continue }",Task Dispatch Logic,Dispatches tasks when dependencies met and no conflicts
      3e,/Users/pcstyle/skills/self-subagent/SKILL.md,136,"Wave 1: all tasks with 0 unmet dependencies → spawn all, wait all",Wave Execution Pattern,Groups tasks into parallel waves based on dependencies
    traceTextDiagram: "Self-Subagent Orchestration System\n├── Task Registration & State Management <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:28\n│   ├── register_task() stores metadata <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:28\n│   ├── TASK_STATUS[] tracks execution state <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:19\n│   └── TASK_DEPS[] defines dependencies <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:20\n├── Dependency Resolution Engine <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:36\n│   ├── deps_met() checks completion state <-- 3b\n│   ├── write_conflict() prevents file clashes <-- 3c\n│   └── dispatch_ready() validates & launches <-- 3d\n├── Parallel Execution Controller <-- /Users/pcstyle/skills/self-subagent/SKILL.md:180\n│   ├── spawn_task() creates subprocess <-- 3a\n│   ├── timeout wrapper prevents hangs <-- /Users/pcstyle/skills/self-subagent/SKILL.md:192\n│   └── background execution with PIDs <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:82\n├── Wave-Based Scheduler <-- /Users/pcstyle/skills/self-subagent/SKILL.md:131\n│   ├── Wave 1: zero-dependency tasks <-- 3e\n│   ├── Wave N: dependencies resolved <-- /Users/pcstyle/skills/self-subagent/SKILL.md:137\n│   └── Serial execution within waves <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:127\n└── Process Monitoring & Collection <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:87\n    ├── wait for PIDs & check exit codes <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:91\n    ├── collect results from temp files <-- /Users/pcstyle/skills/self-subagent/SKILL.md:224\n    └── promote to next wave or retry <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:108"
    traceGuide: "# Motivation\n\nWhen you need to make complex changes to a codebase - like adding logging to multiple modules, writing tests for several components, or refactoring interconnected systems - doing everything **sequentially** is painfully slow. A single AI agent can only work on one thing at a time, even when tasks are completely independent. The self-subagent system solves this by letting you **spawn parallel copies of yourself** to work on multiple tasks simultaneously, while intelligently managing dependencies and preventing conflicts.\n\n# Details\n\nThe system works through a **dependency graph scheduler** that breaks your complex task into independent sub-tasks. Each task declares what files it will read and write, along with any dependencies on other tasks [3b]. The scheduler then groups tasks into \"waves\" - Wave 1 contains all tasks with no dependencies that can run in parallel [3e], Wave 2 contains tasks whose Wave 1 dependencies completed, and so on.\n\nBefore spawning any tasks, the system performs **conflict detection** to ensure no two parallel tasks try to write the same file [3c]. Each task is launched as a fire-and-forget subprocess with a timeout wrapper [3a] and tracks execution status in shared state arrays. The system monitors process completion, collects results from temporary files, and either promotes tasks to the next wave or retries failures with injected error context.\n\nThe key innovation is that this works with **any AI coding CLI** - it discovers the non-interactive execution mode for whatever tool you're using (Amp, Claude, Cursor, etc.) and adapts the spawning pattern accordingly. This gives you massive parallelization while maintaining safety through resource locking and dependency management."
  - id: "4"
    title: Resource Locking and Parallel Control
    description: Resource management patterns that enable safe parallel subagent execution
    locations[5]{id,path,lineNumber,lineContent,title,description}:
      4a,/Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md,61,"Tools declare `serial: true` or `resourceKeys: [{key, mode: \"read\"|\"write\"}]`",Tool Resource Declaration,Tools declare their resource requirements and serialization needs
      4b,/Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md,62,Two tools sharing a write key on the same resource → serialize,Write Conflict Rule,Write operations on same resource are serialized
      4c,/Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md,63,Read-read or disjoint keys → parallel,Parallel Execution Rule,Read-only or disjoint resources can run in parallel
      4d,/Users/pcstyle/skills/self-subagent/references/orchestration.md,76,(( $(count_running) >= MAX_PARALLEL )) && return,Concurrency Throttling,Limits maximum concurrent subagents to prevent resource contention
      4e,/Users/pcstyle/skills/self-subagent/references/orchestration.md,172,"git worktree add \"$dir\" -b \"subagent/$id\" HEAD --quiet",Worktree Isolation,Creates isolated git worktrees for overlapping file writes
    traceTextDiagram: "Resource Management System\n├── Tool Resource Declarations\n│   └── Tools declare resource keys <-- 4a\n├── Resource Conflict Resolution\n│   ├── Write conflict check <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:46\n│   │   └── Same resource + write key <-- 4b\n│   └── Parallel execution allowed <-- /Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md:63\n│       └── Read-only or disjoint keys <-- 4c\n├── Concurrency Control\n│   ├── Count running tasks <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:60\n│   │   └── Check max parallel limit <-- 4d\n│   └── Task dispatch coordination <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:73\n└── File Isolation Strategies\n    ├── Git worktree creation <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:169\n    │   └── Isolated worktree per task <-- 4e\n    └── Merge results back to main <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:192"
    traceGuide: "# Motivation\n\nWhen multiple AI subagents work in parallel, they can **corrupt each other's work** by writing to the same files simultaneously or overwhelm system resources. The resource management system solves this by providing **safe parallel execution** through intelligent resource locking, conflict detection, and isolation strategies.\n\n# Details\n\nThe system uses a **declarative resource model** where tools specify their resource needs upfront [4a]. Each tool declares whether it needs serial execution or specific resource keys with read/write modes. The conflict resolution engine then enforces two simple rules: write operations on the same resource are serialized [4b], while read-only or disjoint resources can run in parallel [4c].\n\n**Concurrency throttling** prevents system overload by tracking running tasks and enforcing a maximum parallel limit [4d]. When tasks must modify overlapping files, the system creates **git worktree isolation** - giving each subagent its own working copy [4e]. This allows true parallel work without file conflicts, later merging results back to the main branch.\n\nThe entire approach enables **massive parallelization** while maintaining data integrity and system stability."
  - id: "5"
    title: Error Recovery and State Management
    description: "Error handling, retry mechanisms, and state tracking across subagent systems"
    locations[5]{id,path,lineNumber,lineContent,title,description}:
      5a,/Users/pcstyle/skills/self-subagent/references/orchestration.md,243,"retry_with_context() { local prev_error=$(tail -80 \"$TMPDIR/$id.attempt$((attempt-1)).out\")",Context-Aware Retry,Retries failed tasks with previous error context injected
      5b,/Users/pcstyle/amp-extract/node_modules/@sourcegraph/amp/dist/AGENTS.md,67,Failed subagent output is summarized (via Gemini) and fed back to the parent agent,Error Summarization,Failed subagent outputs are summarized for parent agent analysis
      5c,/Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts,232,this.abortRequested = true; this.activeApiAbort?.(),Subagent Abort Handling,Cascades abort signals to active subagent processes
      5d,/Users/pcstyle/skills/self-subagent/references/orchestration.md,91,"if (!kill -0 \"$pid\" 2>/dev/null; then wait \"$pid\"; if (( $? == 0 )); then TASK_STATUS[$id]=\"done\"",Process Status Monitoring,Monitors subagent process completion and updates status
      5e,/Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts,773,const didCompact = this.compactConversationForContextWindow(conversation),Context Window Recovery,Compacts conversation history on context overflow errors
    traceTextDiagram: "Error Recovery & State Management\n├── Subagent Process Monitoring\n│   ├── Process lifecycle tracking\n│   │   └── kill -0 check + wait() <-- 5d\n│   └── Status updates to TASK_STATUS <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:19\n├── Error Context Injection\n│   ├── Previous error capture <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:243\n│   │   └── tail -80 error output <-- 5a\n│   └── Retry with context injection <-- /Users/pcstyle/skills/self-subagent/references/orchestration.md:236\n├── Abort Signal Propagation\n│   ├── Abort request received <-- /Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts:252\n│   │   └── abortRequested = true <-- 5c\n│   └── Active API abortion\n│       └── activeApiAbort?.() <-- 5c\n├── Context Window Recovery\n│   ├── Context overflow detected <-- /Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts:772\n│   │   └── compactConversation() call <-- 5e\n│   └── Conversation truncation <-- /Users/pcstyle/cline/src/core/task/tools/subagent/SubagentRunner.ts:696\n└── Error Summarization\n    └── Gemini summarization <-- 5b"
    traceGuide: "# Motivation\n\nWhen you spawn multiple AI subagents to work in parallel, **things will fail**. Processes crash, context windows overflow, resources conflict, and network calls timeout. Without robust error recovery, a single failed subagent can cascade and break the entire parallel workflow, wasting time and leaving tasks incomplete. The system needs to detect failures quickly, inject context for intelligent retries, and gracefully handle aborts without leaving orphaned processes.\n\n# Details\n\nThe error recovery system operates at multiple levels. **Process monitoring** continuously tracks subagent lifecycles using `kill -0` checks and updates a shared `TASK_STATUS` array [5d]. When a process exits, the system determines if it completed successfully or failed.\n\nFor **context-aware retries**, failed outputs are captured using `tail -80` to get the last 80 lines of error output [5a]. This error context is injected into the retry prompt so the subagent can fix its specific mistake rather than repeating the same error [5a].\n\nThe **abort propagation** mechanism ensures clean shutdowns. When `abortRequested` is set to true [5c], the system immediately calls `activeApiAbort?.()` to terminate any active API streams [5c]. This prevents orphaned processes from continuing to consume resources.\n\n**Context window recovery** handles the common problem of subagent conversations growing too large. When `checkContextWindowExceededError` detects an overflow [5e], the system automatically compacts the conversation by removing older messages while preserving essential context [5e].\n\nFinally, **error summarization** uses Gemini to condense failed subagent outputs into concise summaries that are fed back to the parent agent for analysis and decision-making [5b]."
description: "Comprehensive mapping of the Amp Subagent System Architecture covering core spawning flows in [1a], Cline's execution engine in [2a], orchestration patterns in [3a], resource management in [4a], and error recovery mechanisms in [5a]."
mermaidDiagram: "graph TB\n    subgraph AmpCore[\"Amp Core Spawning\"]\n        style AmpCore fill:#a5d8ff\n        1a[\"1a: runLibrarianSubagent\"]\n        1b[\"1b: Agent Spec Construction\"]\n        1c[\"1c: AgentRunner.run\"]\n        1d[\"1d: Output Processing\"]\n        1a --> 1b --> 1c --> 1d\n    end\n\n    subgraph ClineExec[\"Cline Execution Engine\"]\n        style ClineExec fill:#fcc2d7\n        2a[\"2a: SubagentRunner.run\"]\n        2b[\"2b: API Handler Creation\"]\n        2c[\"2c: System Prompt Construction\"]\n        2d[\"2d: Stream Processing Loop\"]\n        2e[\"2e: Tool Execution\"]\n        2a --> 2b --> 2c --> 2d --> 2e\n    end\n\n    subgraph SelfSubagent[\"Self-Subagent Orchestration\"]\n        style SelfSubagent fill:#ffec99\n        3a[\"3a: spawn_task\"]\n        3b[\"3b: Dependency Checking\"]\n        3c[\"3c: Write Conflict Detection\"]\n        3d[\"3d: Task Dispatch Logic\"]\n        3e[\"3e: Wave Execution Pattern\"]\n        3a --> 3b\n        3b --> 3d\n        3c --> 3d\n        3d --> 3e\n    end\n\n    subgraph ResourceLock[\"Resource Locking & Parallel Control\"]\n        style ResourceLock fill:#b2f2bb\n        4a[\"4a: Tool Resource Declaration\"]\n        4b[\"4b: Write Conflict Rule\"]\n        4c[\"4c: Parallel Execution Rule\"]\n        4d[\"4d: Concurrency Throttling\"]\n        4e[\"4e: Worktree Isolation\"]\n        4a --> 4b\n        4a --> 4c\n        4d -.-> 4e\n    end\n\n    subgraph ErrorRecovery[\"Error Recovery & State Management\"]\n        style ErrorRecovery fill:#d0bfff\n        5a[\"5a: Context-Aware Retry\"]\n        5b[\"5b: Error Summarization\"]\n        5c[\"5c: Subagent Abort Handling\"]\n        5d[\"5d: Process Status Monitoring\"]\n        5e[\"5e: Context Window Recovery\"]\n        5a --> 5b\n        5c --> 5d\n        5d -.-> 5e\n    end\n\n    Hub[\"Subagent Execution System\"]\n\n    Hub -.-> AmpCore\n    Hub -.-> ClineExec\n    Hub -.-> SelfSubagent\n    Hub -.-> ResourceLock\n    Hub -.-> ErrorRecovery\n\n    1c -->|spawns| 2a\n    2e -->|respects resource constraints| 4a\n    3d -->|uses conflict detection| 4c\n    2d -->|handles failures| 5c\n    3a -->|enables retry| 5a\n    2e -->|manages context| 5e"