diff --git a/src/api.ts b/src/api.ts
index 6150ed4..53c41a1 100644
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@ export interface ApiResponse<T> {
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
+}
+
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
 }
 
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe..b5cedaf 100644
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@ export interface User {
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd78..5d772e7 100644
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@ export interface Payment {
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d..f8c9f7e 100644
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@ export interface UserProfile {
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d5637..0afa514 100644
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,112 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS'
+  | 'FORMAT_CURRENCY_ERROR';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'FORMAT_CURRENCY_ERROR', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}
