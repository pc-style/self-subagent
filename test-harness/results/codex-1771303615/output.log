OpenAI Codex v0.101.0 (research preview)
--------
workdir: /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR] (network access enabled)
reasoning effort: medium
reasoning summaries: detailed
session id: 019c69ec-65e4-76b0-829c-50c22a4f3ecd
--------
user

Use the self-subagent skill to:
Add comprehensive error handling to all 5 modules in src/:

1. src/auth.ts - Add try-catch around auth operations, use custom AuthError class
2. src/payments.ts - Add error handling for payment processing, use PaymentError class  
3. src/user.ts - Add validation error handling, use ValidationError class
4. src/utils.ts - Add error handling for utility functions
5. src/api.ts - Add global error handling and middleware pattern

Requirements:
- Create custom error classes (AuthError, PaymentError, ValidationError) that extend Error
- Add error codes (e.g., AUTH_FAILED, PAYMENT_DECLINED, VALIDATION_ERROR)
- Log errors with structured format: { timestamp: ISO string, code: string, message: string, stack?: string }
- Ensure all async functions have try-catch with proper error handling
- Return type-safe error results where appropriate
- TypeScript must compile without errors (run: cd sample-repo && npx tsc --noEmit)
- Do NOT modify package.json or tsconfig.json

Use parallel subagents for efficiency. Each module can be handled independently.

The subagent should read the existing file first, then add proper error handling while maintaining the existing functionality.

Working directory: /var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo

Follow the self-subagent protocol:
1. Decompose into parallel tasks (one per module)
2. Spawn subagents using codex exec
3. Collect results and verify with typecheck
4. Report which files were modified

mcp: linear starting
mcp: context7 starting
mcp: codebase-retrieval starting
mcp: codex_apps starting
mcp: linear ready
mcp: context7 ready
mcp: codex_apps ready
mcp: codebase-retrieval ready
mcp startup: ready: linear, context7, codex_apps, codebase-retrieval

thinking
**Planning skill file inspection**
codex
I’m going to use the `self-subagent` skill exactly as requested: first I’ll open its `SKILL.md` to follow its protocol, then I’ll fan out one subagent per `src/*.ts` module, merge the edits, and run the TypeScript check.
exec
/bin/zsh -lc "sed -n '1,240p' /Users/pcstyle/.agents/skills/self-subagent/SKILL.md" in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 52ms:
---
name: self-subagent
description: Orchestrate parallel sub-tasks by spawning non-interactive instances of your own CLI as subagents. Use when you need to parallelize work across multiple files, run independent investigations simultaneously, or delegate heavy multi-step tasks. Works with ANY AI coding CLI agent (Amp, Claude Code, Codex, Cursor, OpenCode, aider, Cline, Roo, goose, Windsurf, Copilot CLI, pi, etc.). Triggers on "run in parallel", "subagent", "delegate", "fan out", "concurrent tasks", or any complex task that benefits from parallel execution.
---

# Self-Subagent Orchestration

Spawn parallel copies of yourself in non-interactive mode to do work concurrently.

```
YOU (parent, interactive)
 ├─ spawn ──→ [self --exec "task A"]  ──→ result A ─┐
 ├─ spawn ──→ [self --exec "task B"]  ──→ result B ─┼─→ collect → verify → done
 └─ spawn ──→ [self --exec "task C"]  ──→ result C ─┘
```

Each subagent is **fire-and-forget**: receives a complete prompt, does the work, exits. No follow-ups.

## Phase 1: Discover Your Execute Mode


thinking
**Checking protocol completion**
exec
/bin/zsh -lc "sed -n '241,520p' /Users/pcstyle/.agents/skills/self-subagent/SKILL.md" in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 52ms:

PREVIOUS ATTEMPT FAILED. Error output:
$ERROR

Fix the issue and try again."
  timeout 300 $AGENT_CMD "$RETRY_PROMPT" > "$TMPDIR/$id.retry.out" 2>&1
done
```

After 1 retry, do the task yourself — don't loop.

### 4d. Verify the wave

Run project-wide validation after each wave:

```bash
# Adapt to your project
npx tsc --noEmit && npm test && npm run lint
```


thinking
**Planning CLI discovery command**
codex
I’ve loaded the skill instructions. Next I’ll run the required CLI discovery/test for non-interactive execution, then build a 5-task wave (one file each) and spawn them in parallel with strict write boundaries.
exec
/bin/zsh -lc 'for cmd in amp claude codex cursor opencode aider pi goose cline roo windsurf copilot; do command -v "$cmd" >/dev/null 2>&1 && echo "$cmd"; done' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repoexec
/bin/zsh -lc 'ps -p $PPID -o comm= 2>/dev/null' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo exited 127 in 52ms:

 exited 1 in 52ms:
amp
claude
codex
opencode
pi
cline

thinking
**Verifying shell command availability**

thinking
**Identifying sandbox limitation**
exec
/bin/zsh -lc "codex --help | sed -n '1,220p'" in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repoexec
/bin/zsh -lc "codex run --help | sed -n '1,220p'" in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repoexec
/bin/zsh -lc "codex exec --help | sed -n '1,260p'" in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 52ms:
WARNING: proceeding, even though we could not update PATH: Operation not permitted (os error 1)
Run Codex non-interactively

Usage: codex exec [OPTIONS] [PROMPT] [COMMAND]

Commands:
  resume  Resume a previous session by id or pick the most recent with --last
  review  Run a code review against the current repository
  help    Print this message or the help of the given subcommand(s)

Arguments:
  [PROMPT]
          Initial instructions for the agent. If not provided as an argument (or if `-` is used),
          instructions are read from stdin

Options:
  -c, --config <key=value>
          Override a configuration value that would otherwise be loaded from `~/.codex/config.toml`.
          Use a dotted path (`foo.bar.baz`) to override nested values. The `value` portion is parsed
          as TOML. If it fails to parse as TOML, the raw string is used as a literal.
 succeeded in 52ms:
WARNING: proceeding, even though we could not update PATH: Operation not permitted (os error 1)
Codex CLI

If no subcommand is specified, options will be forwarded to the interactive CLI.

Usage: codex [OPTIONS] [PROMPT]
       codex [OPTIONS] <COMMAND> [ARGS]

Commands:
  exec        Run Codex non-interactively [aliases: e]
  review      Run a code review non-interactively
  login       Manage login
  logout      Remove stored authentication credentials
  mcp         [experimental] Run Codex as an MCP server and manage MCP servers
  mcp-server  [experimental] Run the Codex MCP server (stdio transport)
  app-server  [experimental] Run the app server or related tooling
  app         Launch the Codex desktop app (downloads the macOS installer if missing)
  completion  Generate shell completion scripts
  sandbox     Run commands within a Codex-provided sandbox
  debug       Debugging tools
 succeeded in 52ms:
WARNING: proceeding, even though we could not update PATH: Operation not permitted (os error 1)
Codex CLI

If no subcommand is specified, options will be forwarded to the interactive CLI.

Usage: codex [OPTIONS] [PROMPT]
       codex [OPTIONS] <COMMAND> [ARGS]

Commands:
  exec        Run Codex non-interactively [aliases: e]
  review      Run a code review non-interactively
  login       Manage login
  logout      Remove stored authentication credentials
  mcp         [experimental] Run Codex as an MCP server and manage MCP servers
  mcp-server  [experimental] Run the Codex MCP server (stdio transport)
  app-server  [experimental] Run the app server or related tooling
  app         Launch the Codex desktop app (downloads the macOS installer if missing)
  completion  Generate shell completion scripts
  sandbox     Run commands within a Codex-provided sandbox
  debug       Debugging tools

thinking
**Planning environment command testing**
codex
CLI discovery is complete (`codex exec` is available). I’ll run a quick non-interactive ping test, then launch five parallel `codex exec` tasks with one write target each.

thinking
**Removing invalid exec flag**
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && timeout 30 codex exec --full-auto --sandbox workspace-write "Reply with exactly: PING"' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo exited 1 in 4.71s:
OpenAI Codex v0.101.0 (research preview)
--------
workdir: /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR] (network access enabled)
reasoning effort: medium
reasoning summaries: detailed
session id: 019c69ec-e874-7121-8524-f0e2255d803e
--------
user
Reply with exactly: PING
mcp: codebase-retrieval starting
mcp: codex_apps starting
mcp: context7 starting
mcp: linear starting
2026-02-17T04:47:40.084151Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c69ec-65e4-76b0-829c-50c22a4f3ecd
mcp: context7 failed: MCP client for `context7` failed to start: MCP startup failed: handshaking with MCP server failed: connection closed: initialize response
mcp: linear ready

thinking
**Testing config flag to prevent context7 failure**
codex
The self-subagent ping returned `PING`, but `codex exec` exits non-zero in this sandbox because of MCP startup/shutdown noise. I’ll proceed with subagents anyway, capture outputs, and use actual file diffs plus typecheck as the source of truth.
exec
/bin/zsh -lc "cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && set +e; timeout 30 codex exec --full-auto --sandbox workspace-write -c 'mcp_servers.context7.enabled=false' \"Reply with exactly: PING\" >/tmp/codex_ping.out 2>&1; ec="'$?; echo EXIT:$ec; tail -n 8 /tmp/codex_ping.out' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 3.82s:
EXIT:1
codex
PING
2026-02-17T04:47:55.089548Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
2026-02-17T04:47:55.090589Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
ERROR: Failed to shutdown rollout recorder
tokens used
9,490
PING

thinking
**Planning error class distribution**
exec
/bin/zsh -lc "cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && sed -n '1,240p' src/payments.ts && sed -n '1,240p' src/user.ts" in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repoexec
/bin/zsh -lc "cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && sed -n '1,240p' src/utils.ts && sed -n '1,280p' src/api.ts" in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repoexec
/bin/zsh -lc "cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && ls -la src && sed -n '1,220p' src/auth.ts" in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 51ms:
// Sample utils module - needs error handling
export async function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export function parseJSON<T>(json: string): T {
  return JSON.parse(json) as T;
}

export async function retry<T>(
  fn: () => Promise<T>,
  maxAttempts: number
): Promise<T> {
  let lastError: Error;
  
  for (let i = 0; i < maxAttempts; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
 succeeded in 51ms:
// Sample payments module - needs error handling
export interface Payment {
  id: string;
  amount: number;
  currency: string;
  status: 'pending' | 'completed' | 'failed';
}

export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
  const response = await fetch('/api/payments/process', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ userId, amount, currency })
  });
  
  const data = await response.json();
  return data;
}

export async function refundPayment(paymentId: string): Promise<Payment> {
 succeeded in 52ms:
total 40
drwxr-xr-x@ 7 pcstyle  staff   224 Feb 17 05:46 .
drwxr-xr-x@ 9 pcstyle  staff   288 Feb 17 05:46 ..
-rw-r--r--@ 1 pcstyle  staff  1163 Feb 17 05:46 api.ts
-rw-r--r--@ 1 pcstyle  staff   837 Feb 17 05:46 auth.ts
-rw-r--r--@ 1 pcstyle  staff   825 Feb 17 05:46 payments.ts
-rw-r--r--@ 1 pcstyle  staff   784 Feb 17 05:46 user.ts
-rw-r--r--@ 1 pcstyle  staff   757 Feb 17 05:46 utils.ts
// Sample authentication module - needs error handling
export interface User {
  id: string;
  email: string;
  passwordHash: string;
}

export async function authenticateUser(email: string, password: string): Promise<User> {
  const response = await fetch('/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password })

thinking
**Scoping subagent tasks per file**
codex
Plan and execution graph:

1. `auth-errors`  
writes: `src/auth.ts`  
depends_on: none  
task: add `AuthError`, error codes, structured logging, and async try/catch wrappers while preserving current behavior.

2. `payments-errors`  
writes: `src/payments.ts`  
depends_on: none  
task: add `PaymentError`, payment error codes/logging, and robust async handling.

3. `user-errors`  
writes: `src/user.ts`  
depends_on: none  
task: add `ValidationError`, validation/error handling for profile and email flows.

4. `utils-errors`  
writes: `src/utils.ts`  
depends_on: none  
task: add utility-safe error handling, structured logs, and safer retry/parse behavior.

5. `api-errors`  
writes: `src/api.ts`  
depends_on: none  
task: add global API error handling + middleware pattern with typed error results.

Wave 1 is all five tasks in parallel (disjoint writes). After collection, I’ll run `cd sample-repo && npx tsc --noEmit`, then patch any integration issues if needed.

thinking
**Verifying script path and structure**
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && pwd && ls -la' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repoexec
/bin/zsh -lc 'cd /var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && pwd && ls -la' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repoexec
/bin/zsh -lc "cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && rg --files | sed -n '1,120p'" in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 51ms:
/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
total 24
drwxr-xr-x@  9 pcstyle  staff  288 Feb 17 05:46 .
drwx------@  8 pcstyle  staff  256 Feb 17 05:47 ..
drwxr-xr-x@ 15 pcstyle  staff  480 Feb 17 05:47 .git
drwxr-xr-x@  5 pcstyle  staff  160 Feb 17 05:46 node_modules
-rw-r--r--@  1 pcstyle  staff  706 Feb 17 05:46 package-lock.json
-rw-r--r--@  1 pcstyle  staff  257 Feb 17 05:46 package.json
drwxr-xr-x@  7 pcstyle  staff  224 Feb 17 05:46 src
drwxr-xr-x@  2 pcstyle  staff   64 Feb 17 05:46 tests
-rw-r--r--@  1 pcstyle  staff  310 Feb 17 05:46 tsconfig.json
 succeeded in 51ms:
/private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
total 24
drwxr-xr-x@  9 pcstyle  staff  288 Feb 17 05:46 .
drwx------@  8 pcstyle  staff  256 Feb 17 05:47 ..
drwxr-xr-x@ 15 pcstyle  staff  480 Feb 17 05:47 .git
drwxr-xr-x@  5 pcstyle  staff  160 Feb 17 05:46 node_modules
-rw-r--r--@  1 pcstyle  staff  706 Feb 17 05:46 package-lock.json
-rw-r--r--@  1 pcstyle  staff  257 Feb 17 05:46 package.json
drwxr-xr-x@  7 pcstyle  staff  224 Feb 17 05:46 src
drwxr-xr-x@  2 pcstyle  staff   64 Feb 17 05:46 tests
-rw-r--r--@  1 pcstyle  staff  310 Feb 17 05:46 tsconfig.json
 succeeded in 51ms:
src/auth.ts
src/user.ts
src/payments.ts
src/api.ts
src/utils.ts
tsconfig.json
package.json
package-lock.json
node_modules/typescript/SECURITY.md
node_modules/typescript/ThirdPartyNoticeText.txt
node_modules/typescript/LICENSE.txt
node_modules/typescript/lib/lib.es2015.d.ts
node_modules/typescript/lib/lib.es2015.collection.d.ts
node_modules/typescript/lib/lib.esnext.array.d.ts
node_modules/typescript/lib/lib.es2017.arraybuffer.d.ts
node_modules/typescript/lib/lib.es2015.symbol.d.ts
node_modules/typescript/lib/lib.webworker.importscripts.d.ts
node_modules/typescript/lib/tr/diagnosticMessages.generated.json
node_modules/typescript/lib/lib.es2019.d.ts
node_modules/typescript/lib/lib.es2017.string.d.ts

thinking
**Designing parallel subagent execution**
codex
I’m starting the parallel subagent wave now: five `codex exec` runs in the same repo, each constrained to one module file, then I’ll collect their output and inspect the resulting diffs.
exec
/bin/zsh -lc 'cd /var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
set +e
TMPDIR=$(mktemp -d)

cat > "$TMPDIR/auth.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add comprehensive error handling to src/auth.ts while preserving existing functionality.
WORKING DIRECTORY: /var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/auth.ts
MODIFY: src/auth.ts
DO NOT MODIFY: any file except src/auth.ts
CONSTRAINTS:
- Read src/auth.ts before editing.
- Add a custom AuthError class that extends Error.
- Add error codes including AUTH_FAILED.
- Log errors in structured format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure all async functions in this file have try-catch with proper error handling.
- Keep TypeScript strict-safe and preserve existing exported functions and behavior.
- Do not use any.
DELIVERABLES:
- Updated src/auth.ts with AuthError + robust error handling.
EOF

cat > \""'$TMPDIR/payments.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add comprehensive error handling to src/payments.ts while preserving existing functionality.
WORKING DIRECTORY: /var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/payments.ts
MODIFY: src/payments.ts
DO NOT MODIFY: any file except src/payments.ts
CONSTRAINTS:
- Read src/payments.ts before editing.
- Add a custom PaymentError class that extends Error.
- Add error codes including PAYMENT_DECLINED.
- Log errors in structured format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure all async functions in this file have try-catch with proper error handling.
- Keep TypeScript strict-safe and preserve existing exported functions and behavior.
- Do not use any.
DELIVERABLES:
- Updated src/payments.ts with PaymentError + robust error handling.
EOF

cat > \""'$TMPDIR/user.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add comprehensive validation and error handling to src/user.ts while preserving existing functionality.
WORKING DIRECTORY: /var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/user.ts
MODIFY: src/user.ts
DO NOT MODIFY: any file except src/user.ts
CONSTRAINTS:
- Read src/user.ts before editing.
- Add a custom ValidationError class that extends Error.
- Add error codes including VALIDATION_ERROR.
- Log errors in structured format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure all async functions in this file have try-catch with proper error handling.
- Add validation-oriented handling where appropriate without breaking existing exports.
- Keep TypeScript strict-safe. Do not use any.
DELIVERABLES:
- Updated src/user.ts with ValidationError + robust error handling.
EOF

cat > \""'$TMPDIR/utils.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add comprehensive error handling to src/utils.ts while preserving existing functionality.
WORKING DIRECTORY: /var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/utils.ts
MODIFY: src/utils.ts
DO NOT MODIFY: any file except src/utils.ts
CONSTRAINTS:
- Read src/utils.ts before editing.
- Add structured error logging in format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure async functions in this file have proper try-catch handling.
- Keep parse/retry utilities type-safe and robust.
- Preserve existing exported functions and behavior as much as possible.
- Keep TypeScript strict-safe. Do not use any.
DELIVERABLES:
- Updated src/utils.ts with robust utility error handling.
EOF

cat > \""'$TMPDIR/api.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add global error handling and middleware pattern to src/api.ts while preserving existing functionality.
WORKING DIRECTORY: /var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/api.ts
MODIFY: src/api.ts
DO NOT MODIFY: any file except src/api.ts
CONSTRAINTS:
- Read src/api.ts before editing.
- Add global error handling and a middleware pattern.
- Add structured error logging format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure async functions in this file have try-catch with proper error handling.
- Return type-safe error results where appropriate.
- Preserve existing exports and behavior where possible.
- Keep TypeScript strict-safe. Do not use any.
DELIVERABLES:
- Updated src/api.ts with middleware-based global error handling.
EOF

run_task() {
  local name=\""'$1"
  local prompt_file="$2"
  timeout 240 codex exec --full-auto --sandbox workspace-write "$(cat "$prompt_file")" >"$TMPDIR/$name.out" 2>&1 &
  echo $!
}

P1=$(run_task auth "$TMPDIR/auth.prompt")
P2=$(run_task payments "$TMPDIR/payments.prompt")
P3=$(run_task user "$TMPDIR/user.prompt")
P4=$(run_task utils "$TMPDIR/utils.prompt")
P5=$(run_task api "$TMPDIR/api.prompt")

for p in $P1 $P2 $P3 $P4 $P5; do
  wait "$p"
  echo "pid:$p exit:$?"
done > "$TMPDIR/exits.txt"

echo "=== EXITS ==="
cat "$TMPDIR/exits.txt"

echo "=== TAIL auth ==="; tail -n 20 "$TMPDIR/auth.out"
echo "=== TAIL payments ==="; tail -n 20 "$TMPDIR/payments.out"
echo "=== TAIL user ==="; tail -n 20 "$TMPDIR/user.out"
echo "=== TAIL utils ==="; tail -n 20 "$TMPDIR/utils.out"
echo "=== TAIL api ==="; tail -n 20 "$TMPDIR/api.out"

echo "=== DIFF STAT ==="
git diff --stat
' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 52ms:
mktemp: mkdtemp failed on /var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.K0icPm4DgG: Operation not permitted
zsh:5: operation not permitted: /auth.prompt
zsh:24: operation not permitted: /payments.prompt
zsh:43: operation not permitted: /user.prompt
zsh:62: operation not permitted: /utils.prompt
zsh:80: operation not permitted: /api.prompt
run_task:3: nice(5) failed: operation not permitted
cat: /auth.prompt: No such file or directory
run_task:3: operation not permitted: /auth.out
run_task:3: nice(5) failed: operation not permitted
cat: /payments.prompt: No such file or directory
run_task:3: operation not permitted: /payments.out
run_task:3: nice(5) failed: operation not permitted
cat: /user.prompt: No such file or directory
run_task:3: operation not permitted: /user.out
run_task:3: nice(5) failed: operation not permitted
cat: /utils.prompt: No such file or directory
run_task:3: operation not permitted: /utils.out
run_task:3: nice(5) failed: operation not permitted
cat: /api.prompt: No such file or directory

thinking
**Adjusting temp directory and avoiding function**
codex
The first spawn attempt failed due sandbox write restrictions for the default temp path. I’m retrying with explicit temp files under `/tmp`, then collecting per-task logs and diffs.
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
set +e
TMPDIR=$(mktemp -d /tmp/selfsub.XXXXXX)

echo "TMPDIR=$TMPDIR"

cat > "$TMPDIR/auth.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add comprehensive error handling to src/auth.ts while preserving existing functionality.
WORKING DIRECTORY: /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/auth.ts
MODIFY: src/auth.ts
DO NOT MODIFY: any file except src/auth.ts
CONSTRAINTS:
- Read src/auth.ts before editing.
- Add a custom AuthError class that extends Error.
- Add error codes including AUTH_FAILED.
- Log errors in structured format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure all async functions in this file have try-catch with proper error handling.
- Keep TypeScript strict-safe and preserve existing exported functions and behavior.
- Do not use any.
DELIVERABLES:
- Updated src/auth.ts with AuthError + robust error handling.
EOF

cat > \""'$TMPDIR/payments.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add comprehensive error handling to src/payments.ts while preserving existing functionality.
WORKING DIRECTORY: /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/payments.ts
MODIFY: src/payments.ts
DO NOT MODIFY: any file except src/payments.ts
CONSTRAINTS:
- Read src/payments.ts before editing.
- Add a custom PaymentError class that extends Error.
- Add error codes including PAYMENT_DECLINED.
- Log errors in structured format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure all async functions in this file have try-catch with proper error handling.
- Keep TypeScript strict-safe and preserve existing exported functions and behavior.
- Do not use any.
DELIVERABLES:
- Updated src/payments.ts with PaymentError + robust error handling.
EOF

cat > \""'$TMPDIR/user.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add comprehensive validation and error handling to src/user.ts while preserving existing functionality.
WORKING DIRECTORY: /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/user.ts
MODIFY: src/user.ts
DO NOT MODIFY: any file except src/user.ts
CONSTRAINTS:
- Read src/user.ts before editing.
- Add a custom ValidationError class that extends Error.
- Add error codes including VALIDATION_ERROR.
- Log errors in structured format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure all async functions in this file have try-catch with proper error handling.
- Add validation-oriented handling where appropriate without breaking existing exports.
- Keep TypeScript strict-safe. Do not use any.
DELIVERABLES:
- Updated src/user.ts with ValidationError + robust error handling.
EOF

cat > \""'$TMPDIR/utils.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add comprehensive error handling to src/utils.ts while preserving existing functionality.
WORKING DIRECTORY: /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/utils.ts
MODIFY: src/utils.ts
DO NOT MODIFY: any file except src/utils.ts
CONSTRAINTS:
- Read src/utils.ts before editing.
- Add structured error logging in format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure async functions in this file have proper try-catch handling.
- Keep parse/retry utilities type-safe and robust.
- Preserve existing exported functions and behavior as much as possible.
- Keep TypeScript strict-safe. Do not use any.
DELIVERABLES:
- Updated src/utils.ts with robust utility error handling.
EOF

cat > \""'$TMPDIR/api.prompt" <<'"'EOF'
ROLE: You are a focused code executor. Do exactly what is asked. Do not explore beyond scope.
GOAL: Add global error handling and middleware pattern to src/api.ts while preserving existing functionality.
WORKING DIRECTORY: /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
READ FIRST: src/api.ts
MODIFY: src/api.ts
DO NOT MODIFY: any file except src/api.ts
CONSTRAINTS:
- Read src/api.ts before editing.
- Add global error handling and a middleware pattern.
- Add structured error logging format: { timestamp: ISO string, code: string, message: string, stack?: string }.
- Ensure async functions in this file have try-catch with proper error handling.
- Return type-safe error results where appropriate.
- Preserve existing exports and behavior where possible.
- Keep TypeScript strict-safe. Do not use any.
DELIVERABLES:
- Updated src/api.ts with middleware-based global error handling.
EOF

(timeout 240 codex exec --full-auto --sandbox workspace-write \""'$(cat "$TMPDIR/auth.prompt")" >"$TMPDIR/auth.out" 2>&1) &
P1=$!
(timeout 240 codex exec --full-auto --sandbox workspace-write "$(cat "$TMPDIR/payments.prompt")" >"$TMPDIR/payments.out" 2>&1) &
P2=$!
(timeout 240 codex exec --full-auto --sandbox workspace-write "$(cat "$TMPDIR/user.prompt")" >"$TMPDIR/user.out" 2>&1) &
P3=$!
(timeout 240 codex exec --full-auto --sandbox workspace-write "$(cat "$TMPDIR/utils.prompt")" >"$TMPDIR/utils.out" 2>&1) &
P4=$!
(timeout 240 codex exec --full-auto --sandbox workspace-write "$(cat "$TMPDIR/api.prompt")" >"$TMPDIR/api.out" 2>&1) &
P5=$!

wait "$P1"; E1=$?
wait "$P2"; E2=$?
wait "$P3"; E3=$?
wait "$P4"; E4=$?
wait "$P5"; E5=$?

echo "EXITS auth=$E1 payments=$E2 user=$E3 utils=$E4 api=$E5"

echo "=== TAIL auth ==="; tail -n 14 "$TMPDIR/auth.out"
echo "=== TAIL payments ==="; tail -n 14 "$TMPDIR/payments.out"
echo "=== TAIL user ==="; tail -n 14 "$TMPDIR/user.out"
echo "=== TAIL utils ==="; tail -n 14 "$TMPDIR/utils.out"
echo "=== TAIL api ==="; tail -n 14 "$TMPDIR/api.out"

echo "=== DIFF STAT ==="
git diff --stat

echo "LOGDIR:$TMPDIR"
' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo
thinking
**Implementing update polling via stdin**
codex
All five subagents are running in parallel now. I’m waiting for completion and will then inspect each output tail plus `git diff --stat`.

thinking
**Noting possible timeout cause**
 succeeded in 1m 42s:
EXITS auth=1 payments=1 user=1 utils=1 api=1
=== TAIL auth ===
7,244
I can’t read or edit `src/auth.ts` in this session because every filesystem command is failing with:

`sandbox-exec: sandbox_apply: Operation not permitted`

Since you required reading that file first and preserving existing behavior, I can’t safely produce the update blind.

Please paste the current contents of `src/auth.ts` here, and I’ll return a fully updated version that:
- adds `AuthError` extending `Error`
- adds error codes including `AUTH_FAILED`
- uses structured error logging
- wraps all async functions in `try/catch`
- preserves all existing exports/behavior
- uses strict-safe TypeScript with no `any`
=== TAIL payments ===
2026-02-17T04:49:32.607410Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
2026-02-17T04:49:32.610410Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
ERROR: Failed to shutdown rollout recorder

thinking
**Designing typed error handling**
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && cat tsconfig.json' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 51ms:
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "lib": ["ES2022", "DOM"]
  },
  "include": ["src/**/*"]
}

thinking
**Planning multi-file edits**
codex
The spawned subagents couldn’t access files in their nested sandbox, so I’m applying the same wave locally now (one pass across the 5 `src/*.ts` files) with the requested error classes, codes, structured logging, try/catch coverage, and API middleware pattern.
file update
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/auth.ts
@@ -7,14 +7,67 @@
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
@@ -22,8 +75,19 @@
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
@@ -32,2 +96,2 @@
   return password.length >= 8;
-}
\ No newline at end of file
+}
apply_patch(auto_approved=true) exited 0 in 31ms:
Success. Updated the following files:
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/auth.ts
file update:
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}

file update:
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}


thinking
**Creating payments user API patches**
file update
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/payments.ts
@@ -8,11 +8,67 @@
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
@@ -20,7 +76,18 @@
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
@@ -29,2 +96,2 @@
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
apply_patch(auto_approved=true) exited 0 in 172ms:
Success. Updated the following files:
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/payments.ts
file update:
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}

file update:
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}

file update
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/user.ts
@@ -8,6 +8,70 @@
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
@@ -15,9 +79,27 @@
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
@@ -25,4 +107,10 @@
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
apply_patch(auto_approved=true) exited 0 in 45ms:
Success. Updated the following files:
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/user.ts
file update:
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}

file update:
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}

codex
Three modules are patched (`auth`, `payments`, `user`). I’m now updating `utils` and `api` to finish global/middleware handling, then I’ll run the requested typecheck.
file update
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/utils.ts
@@ -1,4 +1,61 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
@@ -6,3 +63,9 @@
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
@@ -13,5 +76,11 @@
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
@@ -19,8 +88,11 @@
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
@@ -28,6 +100,12 @@
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}
apply_patch(auto_approved=true) exited 0 in 55ms:
Success. Updated the following files:
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/utils.ts
file update:
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..8812959bef87a1bfe2a9abb3808c2201690142e8
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,111 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}

file update:
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..8812959bef87a1bfe2a9abb3808c2201690142e8
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,111 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}


thinking
**Adjusting error code usage**
file update
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/api.ts
@@ -18,24 +18,132 @@
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
@@ -43,4 +151,37 @@
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
apply_patch(auto_approved=true) exited 0 in 62ms:
Success. Updated the following files:
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/api.ts
file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..8812959bef87a1bfe2a9abb3808c2201690142e8
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,111 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}

file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..8812959bef87a1bfe2a9abb3808c2201690142e8
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,111 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}


thinking
**Running TypeScript compile checks**
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && npx tsc --noEmit' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo exited 1 in 815ms:
node:internal/modules/cjs/loader:1372
  throw err;
  ^

Error: Cannot find module '../lib/tsc.js'
Require stack:
- /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/node_modules/.bin/tsc
    at Module._resolveFilename (node:internal/modules/cjs/loader:1369:15)
    at defaultResolveImpl (node:internal/modules/cjs/loader:1025:19)
    at resolveForCJSWithHooks (node:internal/modules/cjs/loader:1030:22)
    at Module._load (node:internal/modules/cjs/loader:1179:37)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at wrapModuleLoad (node:internal/modules/cjs/loader:235:24)
    at Module.require (node:internal/modules/cjs/loader:1449:12)
    at require (node:internal/modules/helpers:135:16)
    at Object.<anonymous> (/private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/node_modules/.bin/tsc:2:1)
    at Module._compile (node:internal/modules/cjs/loader:1692:14) {
  code: 'MODULE_NOT_FOUND',
  requireStack: [
    '/private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/node_modules/.bin/tsc'
file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..8812959bef87a1bfe2a9abb3808c2201690142e8
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,111 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}


thinking
**Checking local TypeScript compiler availability**
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && ls -la node_modules/typescript/bin && node node_modules/typescript/bin/tsc --noEmit' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 273ms:
total 16
drwxr-xr-x@ 4 pcstyle  staff  128 Feb 17 05:46 .
drwxr-xr-x@ 9 pcstyle  staff  288 Feb 17 05:46 ..
-rwxr-xr-x@ 1 pcstyle  staff   45 Feb 17 05:46 tsc
-rwxr-xr-x@ 1 pcstyle  staff   50 Feb 17 05:46 tsserver
file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..8812959bef87a1bfe2a9abb3808c2201690142e8
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,111 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}


thinking
**Inspecting tsc binary for issues**
codex
I finished implementation across all five modules and ran type checking. The exact `npx tsc --noEmit` path is broken in this repo’s local `.bin` shim, so I validated with `node node_modules/typescript/bin/tsc --noEmit` instead, which passes cleanly. I’ll now summarize the subagent protocol results and modified files.

thinking
**Validating final changes**
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && git status --short' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repoexec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && git diff -- src/auth.ts src/payments.ts src/user.ts src/utils.ts src/api.ts' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 167ms:
 M src/api.ts
 M src/auth.ts
 M src/payments.ts
 M src/user.ts
 M src/utils.ts
 succeeded in 167ms:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4..53c41a1 100644
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@ export interface ApiResponse<T> {
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..8812959bef87a1bfe2a9abb3808c2201690142e8
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,111 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}


thinking
**Running requested TypeScript check**
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && cd sample-repo && npx tsc --noEmit' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo exited 1 in 51ms:
zsh:cd:1: no such file or directory: sample-repo
file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..8812959bef87a1bfe2a9abb3808c2201690142e8
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,111 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}


thinking
**Testing Bun for compilation**
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && bunx tsc --noEmit' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo exited 1 in 96ms:
node:internal/modules/cjs/loader:1372
  throw err;
  ^

Error: Cannot find module '../lib/tsc.js'
Require stack:
- /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/node_modules/.bin/tsc
    at Module._resolveFilename (node:internal/modules/cjs/loader:1369:15)
    at defaultResolveImpl (node:internal/modules/cjs/loader:1025:19)
    at resolveForCJSWithHooks (node:internal/modules/cjs/loader:1030:22)
    at Module._load (node:internal/modules/cjs/loader:1179:37)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at wrapModuleLoad (node:internal/modules/cjs/loader:235:24)
    at Module.require (node:internal/modules/cjs/loader:1449:12)
    at require (node:internal/modules/helpers:135:16)
    at Object.<anonymous> (/private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/node_modules/.bin/tsc:2:1)
    at Module._compile (node:internal/modules/cjs/loader:1692:14) {
  code: 'MODULE_NOT_FOUND',
  requireStack: [
    '/private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/node_modules/.bin/tsc'
file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..8812959bef87a1bfe2a9abb3808c2201690142e8
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,111 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}


thinking
**Planning subagent protocol details**
file update
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/utils.ts
@@ -5,3 +5,4 @@
   | 'RETRY_FAILED'
-  | 'RETRY_INVALID_ATTEMPTS';
+  | 'RETRY_INVALID_ATTEMPTS'
+  | 'FORMAT_CURRENCY_ERROR';
 
@@ -106,3 +107,3 @@
   } catch (error) {
-    const utilityError = toUtilityError(error, 'RETRY_FAILED', 'Currency formatting failed');
+    const utilityError = toUtilityError(error, 'FORMAT_CURRENCY_ERROR', 'Currency formatting failed');
     logUtilityError(utilityError);
apply_patch(auto_approved=true) exited 0 in 74ms:
Success. Updated the following files:
M /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo/src/utils.ts
file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..0afa514370a1208eef48a21749d733e1f5c8975d
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,112 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS'
+  | 'FORMAT_CURRENCY_ERROR';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'FORMAT_CURRENCY_ERROR', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}

file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..0afa514370a1208eef48a21749d733e1f5c8975d
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,112 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS'
+  | 'FORMAT_CURRENCY_ERROR';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'FORMAT_CURRENCY_ERROR', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}


thinking
**Rerunning direct compilation**
codex
I made one small cleanup to `src/utils.ts` (dedicated `FORMAT_CURRENCY_ERROR` code). I’m running a final typecheck pass now.
exec
/bin/zsh -lc 'cd /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo && node node_modules/typescript/bin/tsc --noEmit && git diff --stat' in /private/var/folders/s9/spxl_b2n1bb5lj6hrnmjjjs40000gn/T/tmp.hfxsboKDxE/repo succeeded in 327ms:
 src/api.ts      | 183 +++++++++++++++++++++++++++++++++++++++++++++++++-------
 src/auth.ts     |  98 ++++++++++++++++++++++++------
 src/payments.ts |  95 ++++++++++++++++++++++++-----
 src/user.ts     | 114 +++++++++++++++++++++++++++++++----
 src/utils.ts    | 107 ++++++++++++++++++++++++++++-----
 5 files changed, 518 insertions(+), 79 deletions(-)
file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..0afa514370a1208eef48a21749d733e1f5c8975d
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,112 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS'
+  | 'FORMAT_CURRENCY_ERROR';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'FORMAT_CURRENCY_ERROR', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}


thinking
**Summarizing fallback implementation and verification**
codex
Implemented comprehensive error handling across all 5 modules and followed the self-subagent protocol.

**Self-subagent run (as requested)**
1. Decomposed into 5 parallel tasks (`auth`, `payments`, `user`, `utils`, `api`) with disjoint write targets.
2. Spawned 5 `codex exec` subagents in parallel.
3. Collected results: all 5 subagents exited non-zero due nested sandbox failure (`sandbox_apply: Operation not permitted`) and made no edits.
4. Completed the required edits directly in the parent session, then verified typecheck.

**Modified files**
- `src/auth.ts`
- `src/payments.ts`
- `src/user.ts`
- `src/utils.ts`
- `src/api.ts`

**What was added**
- Custom error classes extending `Error`:
  - `AuthError` in `src/auth.ts`
  - `PaymentError` in `src/payments.ts`
  - `ValidationError` in `src/user.ts`
- Error codes including:
  - `AUTH_FAILED`
  - `PAYMENT_DECLINED`
  - `VALIDATION_ERROR`
  - plus module-specific companion codes
- Structured logging everywhere in the required shape:
  - `{ timestamp, code, message, stack? }`
- `try/catch` around async operations in all modules.
- Global error handling + middleware pattern in `src/api.ts`:
  - `ApiMiddleware`
  - `applyMiddlewares(...)`
  - `withGlobalErrorHandling(...)`
  - `safeApiRequest(...)` for type-safe result handling (`Result<T, ApiError>`)

**Validation**
- `cd sample-repo && npx tsc --noEmit` fails because `sample-repo` directory does not exist.
- `npx tsc --noEmit` in repo fails due broken local `.bin/tsc` shim (`Cannot find module '../lib/tsc.js'`).
- TypeScript check passed with:
  - `node node_modules/typescript/bin/tsc --noEmit`
file update:
diff --git a/src/api.ts b/src/api.ts
index 6150ed4e90a08ec811251cb2788bef7d54e71eda..53c41a161e6effba21335cd2be9cf5ced82022e8
--- a/src/api.ts
+++ b/src/api.ts
@@ -16,31 +16,172 @@
   headers: Record<string, string>;
 }
 
-export async function apiRequest<T>(request: ApiRequest): Promise<ApiResponse<T>> {
-  const response = await fetch(request.endpoint, {
-    method: request.method,
-    headers: {
-      'Content-Type': 'application/json',
-      ...request.headers
-    },
-    body: request.body ? JSON.stringify(request.body) : undefined
-  });
-  
-  const data = await response.json();
-  
-  return {
-    data,
-    status: response.status,
-    headers: {}
+export type ApiErrorCode =
+  | 'API_REQUEST_FAILED'
+  | 'API_INVALID_RESPONSE'
+  | 'API_MIDDLEWARE_FAILED'
+  | 'API_HANDLER_FAILED';
+
+interface ApiLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export type Result<T, E extends Error> = { ok: true; data: T } | { ok: false; error: E };
+
+export type ApiMiddleware = (request: ApiRequest) => ApiRequest | Promise<ApiRequest>;
+
+export class ApiError extends Error {
+  public readonly code: ApiErrorCode;
+
+  public constructor(message: string, code: ApiErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ApiError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logApiError(error: ApiError): void {
+  const entry: ApiLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
   };
+  console.error(entry);
+}
+
+function toApiError(error: unknown, fallbackCode: ApiErrorCode, fallbackMessage: string): ApiError {
+  if (error instanceof ApiError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ApiError(error.message, fallbackCode, { cause: error });
+  }
+  return new ApiError(fallbackMessage, fallbackCode, { cause: error });
+}
+
+async function applyMiddlewares(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[]
+): Promise<ApiRequest> {
+  let currentRequest = request;
+
+  for (const middleware of middlewares) {
+    try {
+      currentRequest = await middleware(currentRequest);
+    } catch (error) {
+      throw toApiError(error, 'API_MIDDLEWARE_FAILED', 'API middleware execution failed');
+    }
+  }
+
+  return currentRequest;
 }
 
+export async function apiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<T>> {
+  try {
+    const resolvedRequest = await applyMiddlewares(request, middlewares);
+    const response = await fetch(resolvedRequest.endpoint, {
+      method: resolvedRequest.method,
+      headers: {
+        'Content-Type': 'application/json',
+        ...resolvedRequest.headers
+      },
+      body: resolvedRequest.body ? JSON.stringify(resolvedRequest.body) : undefined
+    });
+
+    if (!response.ok) {
+      throw new ApiError(`API request failed with status ${response.status}`, 'API_REQUEST_FAILED');
+    }
+
+    const data = (await response.json()) as T;
+    return {
+      data,
+      status: response.status,
+      headers: {}
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_INVALID_RESPONSE', 'API request handling failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function safeApiRequest<T>(
+  request: ApiRequest,
+  middlewares: readonly ApiMiddleware[] = []
+): Promise<ApiResponse<Result<T, ApiError>>> {
+  try {
+    const response = await apiRequest<T>(request, middlewares);
+    return {
+      data: { ok: true, data: response.data },
+      status: response.status,
+      headers: response.headers
+    };
+  } catch (error) {
+    const apiError = toApiError(error, 'API_REQUEST_FAILED', 'Safe API request failed');
+    logApiError(apiError);
+    return {
+      data: { ok: false, error: apiError },
+      status: 500,
+      headers: {}
+    };
+  }
+}
+
 export async function handleAuth(email: string, password: string) {
-  const user = await authenticateUser(email, password);
-  return user;
+  try {
+    const user = await authenticateUser(email, password);
+    return user;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Authentication handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
 }
 
 export async function handlePayment(userId: string, amount: number) {
-  const payment = await processPayment(userId, amount, 'USD');
-  return payment;
-}
\ No newline at end of file
+  try {
+    const payment = await processPayment(userId, amount, 'USD');
+    return payment;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'Payment handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export async function handleUserProfile(userId: string) {
+  try {
+    const userProfile = await getUserProfile(userId);
+    return userProfile;
+  } catch (error) {
+    const apiError = toApiError(error, 'API_HANDLER_FAILED', 'User profile handler failed');
+    logApiError(apiError);
+    throw apiError;
+  }
+}
+
+export function withGlobalErrorHandling<TArgs extends unknown[], TResult>(
+  handler: (...args: TArgs) => Promise<TResult>,
+  code: ApiErrorCode = 'API_HANDLER_FAILED'
+): (...args: TArgs) => Promise<Result<TResult, ApiError>> {
+  return async (...args: TArgs): Promise<Result<TResult, ApiError>> => {
+    try {
+      const data = await handler(...args);
+      return { ok: true, data };
+    } catch (error) {
+      const apiError = toApiError(error, code, 'Global handler captured an error');
+      logApiError(apiError);
+      return { ok: false, error: apiError };
+    }
+  };
+}
diff --git a/src/auth.ts b/src/auth.ts
index 26927fe70d4bd327ad644d6a793b91a51042d481..b5cedafacd7e2a3e312c6712f51990e59ba46fd1
--- a/src/auth.ts
+++ b/src/auth.ts
@@ -5,29 +5,93 @@
   passwordHash: string;
 }
 
+export type AuthErrorCode =
+  | 'AUTH_FAILED'
+  | 'AUTH_NETWORK_ERROR'
+  | 'AUTH_INVALID_RESPONSE'
+  | 'AUTH_TOKEN_REFRESH_FAILED';
+
+interface AuthLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class AuthError extends Error {
+  public readonly code: AuthErrorCode;
+
+  public constructor(message: string, code: AuthErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'AuthError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logAuthError(error: AuthError): void {
+  const entry: AuthLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toAuthError(error: unknown, fallbackCode: AuthErrorCode, fallbackMessage: string): AuthError {
+  if (error instanceof AuthError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new AuthError(error.message, fallbackCode, { cause: error });
+  }
+  return new AuthError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function authenticateUser(email: string, password: string): Promise<User> {
-  const response = await fetch('/api/auth/login', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ email, password })
-  });
-  
-  if (!response.ok) {
-    throw new Error('Authentication failed');
+  try {
+    const response = await fetch('/api/auth/login', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ email, password })
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Authentication failed', 'AUTH_FAILED');
+    }
+
+    const data = (await response.json()) as User;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_NETWORK_ERROR', 'Authentication request failed');
+    logAuthError(authError);
+    throw authError;
   }
-  
-  return response.json();
 }
 
 export async function refreshToken(token: string): Promise<string> {
-  const response = await fetch('/api/auth/refresh', {
-    method: 'POST',
-    headers: { 'Authorization': `Bearer ${token}` }
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch('/api/auth/refresh', {
+      method: 'POST',
+      headers: { Authorization: `Bearer ${token}` }
+    });
+
+    if (!response.ok) {
+      throw new AuthError('Token refresh failed', 'AUTH_TOKEN_REFRESH_FAILED');
+    }
+
+    const data = (await response.json()) as string;
+    return data;
+  } catch (error) {
+    const authError = toAuthError(error, 'AUTH_INVALID_RESPONSE', 'Token refresh request failed');
+    logAuthError(authError);
+    throw authError;
+  }
 }
 
 export function validatePassword(password: string): boolean {
   return password.length >= 8;
-}
\ No newline at end of file
+}
diff --git a/src/payments.ts b/src/payments.ts
index 045dd787c2d43b2562d5768d3474b1230f589a91..5d772e7296656d2d17c098e5be93c24c99945326
--- a/src/payments.ts
+++ b/src/payments.ts
@@ -6,25 +6,92 @@
   status: 'pending' | 'completed' | 'failed';
 }
 
+export type PaymentErrorCode =
+  | 'PAYMENT_DECLINED'
+  | 'PAYMENT_NETWORK_ERROR'
+  | 'PAYMENT_INVALID_RESPONSE'
+  | 'PAYMENT_REFUND_FAILED';
+
+interface PaymentLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class PaymentError extends Error {
+  public readonly code: PaymentErrorCode;
+
+  public constructor(message: string, code: PaymentErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'PaymentError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logPaymentError(error: PaymentError): void {
+  const entry: PaymentLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toPaymentError(error: unknown, fallbackCode: PaymentErrorCode, fallbackMessage: string): PaymentError {
+  if (error instanceof PaymentError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new PaymentError(error.message, fallbackCode, { cause: error });
+  }
+  return new PaymentError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function processPayment(userId: string, amount: number, currency: string): Promise<Payment> {
-  const response = await fetch('/api/payments/process', {
-    method: 'POST',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify({ userId, amount, currency })
-  });
-  
-  const data = await response.json();
-  return data;
+  try {
+    const response = await fetch('/api/payments/process', {
+      method: 'POST',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify({ userId, amount, currency })
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment processing failed', 'PAYMENT_DECLINED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_NETWORK_ERROR', 'Payment request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export async function refundPayment(paymentId: string): Promise<Payment> {
-  const response = await fetch(`/api/payments/${paymentId}/refund`, {
-    method: 'POST'
-  });
-  
-  return response.json();
+  try {
+    const response = await fetch(`/api/payments/${paymentId}/refund`, {
+      method: 'POST'
+    });
+
+    if (!response.ok) {
+      throw new PaymentError('Payment refund failed', 'PAYMENT_REFUND_FAILED');
+    }
+
+    const data = (await response.json()) as Payment;
+    return data;
+  } catch (error) {
+    const paymentError = toPaymentError(error, 'PAYMENT_INVALID_RESPONSE', 'Refund request failed');
+    logPaymentError(paymentError);
+    throw paymentError;
+  }
 }
 
 export function calculateFee(amount: number): number {
   return amount * 0.029 + 0.30;
-}
\ No newline at end of file
+}
diff --git a/src/user.ts b/src/user.ts
index fd5478d8c2cf20037a9c29bd0294d72171b50485..f8c9f7e246d9f1276b587510ba844f16e73f13f6
--- a/src/user.ts
+++ b/src/user.ts
@@ -6,23 +6,111 @@
   preferences: Record<string, unknown>;
 }
 
+export type ValidationErrorCode =
+  | 'VALIDATION_ERROR'
+  | 'USER_FETCH_FAILED'
+  | 'USER_UPDATE_FAILED'
+  | 'USER_INVALID_RESPONSE';
+
+interface ValidationLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+export class ValidationError extends Error {
+  public readonly code: ValidationErrorCode;
+
+  public constructor(message: string, code: ValidationErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'ValidationError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logValidationError(error: ValidationError): void {
+  const entry: ValidationLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toValidationError(
+  error: unknown,
+  fallbackCode: ValidationErrorCode,
+  fallbackMessage: string
+): ValidationError {
+  if (error instanceof ValidationError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new ValidationError(error.message, fallbackCode, { cause: error });
+  }
+  return new ValidationError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function getUserProfile(userId: string): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`);
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`);
+    if (!response.ok) {
+      throw new ValidationError('Failed to fetch user profile', 'USER_FETCH_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User profile request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export async function updateUserProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
-  const response = await fetch(`/api/users/${userId}`, {
-    method: 'PUT',
-    headers: { 'Content-Type': 'application/json' },
-    body: JSON.stringify(updates)
-  });
-  
-  return response.json();
+  try {
+    if (!userId.trim()) {
+      throw new ValidationError('User ID is required', 'VALIDATION_ERROR');
+    }
+    if (typeof updates.email === 'string' && !validateEmail(updates.email)) {
+      throw new ValidationError('Invalid email format', 'VALIDATION_ERROR');
+    }
+
+    const response = await fetch(`/api/users/${userId}`, {
+      method: 'PUT',
+      headers: { 'Content-Type': 'application/json' },
+      body: JSON.stringify(updates)
+    });
+
+    if (!response.ok) {
+      throw new ValidationError('Failed to update user profile', 'USER_UPDATE_FAILED');
+    }
+
+    const data = (await response.json()) as UserProfile;
+    return data;
+  } catch (error) {
+    const validationError = toValidationError(error, 'USER_INVALID_RESPONSE', 'User update request failed');
+    logValidationError(validationError);
+    throw validationError;
+  }
 }
 
 export function validateEmail(email: string): boolean {
-  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
-  return emailRegex.test(email);
-}
\ No newline at end of file
+  try {
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    return emailRegex.test(email);
+  } catch (error) {
+    const validationError = toValidationError(error, 'VALIDATION_ERROR', 'Email validation failed');
+    logValidationError(validationError);
+    return false;
+  }
+}
diff --git a/src/utils.ts b/src/utils.ts
index 77d563780778a509a363aba3f7391cb9b3e7b77c..0afa514370a1208eef48a21749d733e1f5c8975d
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,33 +1,112 @@
 // Sample utils module - needs error handling
+export type UtilityErrorCode =
+  | 'INVALID_DELAY_MS'
+  | 'JSON_PARSE_ERROR'
+  | 'RETRY_FAILED'
+  | 'RETRY_INVALID_ATTEMPTS'
+  | 'FORMAT_CURRENCY_ERROR';
+
+interface UtilityLogEntry {
+  timestamp: string;
+  code: string;
+  message: string;
+  stack?: string;
+}
+
+class UtilityError extends Error {
+  public readonly code: UtilityErrorCode;
+
+  public constructor(message: string, code: UtilityErrorCode, options?: { cause?: unknown }) {
+    super(message);
+    this.name = 'UtilityError';
+    this.code = code;
+    if (options?.cause !== undefined) {
+      (this as Error & { cause?: unknown }).cause = options.cause;
+    }
+  }
+}
+
+function logUtilityError(error: UtilityError): void {
+  const entry: UtilityLogEntry = {
+    timestamp: new Date().toISOString(),
+    code: error.code,
+    message: error.message,
+    stack: error.stack
+  };
+  console.error(entry);
+}
+
+function toUtilityError(error: unknown, fallbackCode: UtilityErrorCode, fallbackMessage: string): UtilityError {
+  if (error instanceof UtilityError) {
+    return error;
+  }
+  if (error instanceof Error) {
+    return new UtilityError(error.message, fallbackCode, { cause: error });
+  }
+  return new UtilityError(fallbackMessage, fallbackCode, { cause: error });
+}
+
 export async function delay(ms: number): Promise<void> {
-  return new Promise(resolve => setTimeout(resolve, ms));
+  try {
+    if (!Number.isFinite(ms) || ms < 0) {
+      throw new UtilityError('Delay duration must be a non-negative finite number', 'INVALID_DELAY_MS');
+    }
+    await new Promise<void>((resolve) => {
+      setTimeout(resolve, ms);
+    });
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'INVALID_DELAY_MS', 'Delay operation failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export function parseJSON<T>(json: string): T {
-  return JSON.parse(json) as T;
+  try {
+    return JSON.parse(json) as T;
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'JSON_PARSE_ERROR', 'Failed to parse JSON');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
 }
 
 export async function retry<T>(
   fn: () => Promise<T>,
   maxAttempts: number
 ): Promise<T> {
-  let lastError: Error;
-  
-  for (let i = 0; i < maxAttempts; i++) {
+  if (!Number.isInteger(maxAttempts) || maxAttempts < 1) {
+    const utilityError = new UtilityError('maxAttempts must be a positive integer', 'RETRY_INVALID_ATTEMPTS');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+
+  let lastError: UtilityError | null = null;
+
+  for (let i = 0; i < maxAttempts; i += 1) {
     try {
       return await fn();
     } catch (error) {
-      lastError = error as Error;
-      await delay(1000 * (i + 1));
+      lastError = toUtilityError(error, 'RETRY_FAILED', `Attempt ${i + 1} failed`);
+      logUtilityError(lastError);
+      if (i < maxAttempts - 1) {
+        await delay(1000 * (i + 1));
+      }
     }
   }
-  
-  throw lastError!;
+
+  throw lastError ?? new UtilityError('Retry failed without error details', 'RETRY_FAILED');
 }
 
 export function formatCurrency(amount: number, currency: string): string {
-  return new Intl.NumberFormat('en-US', {
-    style: 'currency',
-    currency: currency
-  }).format(amount);
-}
\ No newline at end of file
+  try {
+    return new Intl.NumberFormat('en-US', {
+      style: 'currency',
+      currency
+    }).format(amount);
+  } catch (error) {
+    const utilityError = toUtilityError(error, 'FORMAT_CURRENCY_ERROR', 'Currency formatting failed');
+    logUtilityError(utilityError);
+    throw utilityError;
+  }
+}

tokens used
83,604
Implemented comprehensive error handling across all 5 modules and followed the self-subagent protocol.

**Self-subagent run (as requested)**
1. Decomposed into 5 parallel tasks (`auth`, `payments`, `user`, `utils`, `api`) with disjoint write targets.
2. Spawned 5 `codex exec` subagents in parallel.
3. Collected results: all 5 subagents exited non-zero due nested sandbox failure (`sandbox_apply: Operation not permitted`) and made no edits.
4. Completed the required edits directly in the parent session, then verified typecheck.

**Modified files**
- `src/auth.ts`
- `src/payments.ts`
- `src/user.ts`
- `src/utils.ts`
- `src/api.ts`

**What was added**
- Custom error classes extending `Error`:
  - `AuthError` in `src/auth.ts`
  - `PaymentError` in `src/payments.ts`
  - `ValidationError` in `src/user.ts`
- Error codes including:
  - `AUTH_FAILED`
  - `PAYMENT_DECLINED`
  - `VALIDATION_ERROR`
  - plus module-specific companion codes
- Structured logging everywhere in the required shape:
  - `{ timestamp, code, message, stack? }`
- `try/catch` around async operations in all modules.
- Global error handling + middleware pattern in `src/api.ts`:
  - `ApiMiddleware`
  - `applyMiddlewares(...)`
  - `withGlobalErrorHandling(...)`
  - `safeApiRequest(...)` for type-safe result handling (`Result<T, ApiError>`)

**Validation**
- `cd sample-repo && npx tsc --noEmit` fails because `sample-repo` directory does not exist.
- `npx tsc --noEmit` in repo fails due broken local `.bin/tsc` shim (`Cannot find module '../lib/tsc.js'`).
- TypeScript check passed with:
  - `node node_modules/typescript/bin/tsc --noEmit`
